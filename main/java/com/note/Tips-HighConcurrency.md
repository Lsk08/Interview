* 高并发
    1. 无状态 无状态利于水平扩展 例如应用无状态，而配置环境有状态【不同的服务ip,database 不同】，所以需要利用配置文件或者配置中心指定
    也就是说 扩展难度 有状态 > 无状态
        * 其实对于应用也是 无状态服务比较好处理  有状态的需要额外记录状态，比如session cookie redis 等等，也就是类似于配置文件
        
    2. 系统拆分: 
        1. 系统/业务 + 功能模块 也就是package到class的拆分
        2. 读写 
            * 读:加入缓存 数据异构 -> 聚合分散在各处的数据 
            * 写:分库分表
        3. AOP 例如CDN
        4. 代码维护 eg. 三层
        
    3. 服务化 
        * 进程内服务->单机远程->集群手动注册->集群自动注册和发现->服务的分组/隔离/路由->服务治理如限流/白名单
        * 一般java -> 一般的web -> nginx -> dubbo + zk ->...  当前熟悉【1】【2】 了解【3】【4】
        
    4. 消息队列
        * 分发 一对多
        * 解耦
        * 异步
        * 流量分担
        * case: 库存扣减 
            * redis -> 日志 -> 队列 -> DB 也就是先通过redis 扣减 然后由队列 同步到DB
        * case: 订单
            * 订单 -> redis + 【订单表 -> 队列 -> 订单中心表】
            * 用户查单直接走redis 下单入库走队列
            * 另有订单中心修改状态 
            * 由于mq的异步 需要重试机制
            
    5. 数据异构
        * 数据异构 对已有数据进行归档 增加性能和稳定性
                * eg.库存按照订单id排列 如果需要某一用户的订单就需要从多个数据源获得数据 此时如果能把这些数据按照用户id聚合
                就会好很多
                
        * 异构步骤
            * 通过MQ 更新数据变化，然后储存到redis或者kv
            * 从多个数据源获得数据 【? 如何做 MQ推送】
            * 前端只要一次请求就可以获得所有数据
            * 除了增加性能之外 也可以增加稳定性，例如mq延迟而不影响前端显示，只是不实时
                
    6. 缓存银弹
        * 客户端
            * 浏览器 Expires Cache-Control
            * 客户端应用 静态资源
        * 客户端网络
        * 广域网
            * CDN 镜像 P2P
        * 网站网络
            * 接入层
                * nginx
            * 应用层
                * 堆内/外缓存
                * local redis 无需网络连接 速度更快 适合小量缓存
            * 分布式
                * 分布式 redis
            * 静态化
            * 使用服务器操作系统的缓存机制
                
     7. 并发化 对于没有依赖的数据可以并发执行