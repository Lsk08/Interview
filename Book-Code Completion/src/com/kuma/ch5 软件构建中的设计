隐藏秘密
    - 隐藏复杂度
    - 隐藏变化源
    激发良好的设计思路、实践
        仅仅按照面向对象的思路有时不足以形成良好的设计
            - 用常量名取代字面常量
            - 好的子程序和名称
            - 类和子系统分解交互的决策
        隐藏信息有助于形成公开接口

check box
    尝试用多种方案分解系统 已确定最佳方案
        软件系统 -> 子系统和包 -> 类 -> 数据 和 子程序 -> 子程序内部
            子系统和包: 定义子系统之间交互的规则 todo 从功能上划分系统
                基本规则 不要有循环依赖
                按照功能来区分 常见的有哪些子系统 todo 常见的功能系统
                    - 数据存储
                    - 业务规则
                    - 应用
                    - 工具
                    - 用户界面/交互
                目前只考虑了 dao -> service -> controller 的简单层次规则  层级之间依次访问 不能跨级
                可以考虑把业务规则放在 service -- controller 之间
                    - service 处理底层的数据聚合 拆分
                    - 业务规则分为面向客户 和 面向后台的
                        - 客户端 业务层处理业务逻辑 逾期 进度的节点映射 等等
                        - 后台 service 层 复用
                    - controller 处理页面交互的相关
                这里需要从功能考虑各个子系统的功能和交互规则 todo 定义系统之间的交互
                    - 是否允许应用层直接访问数据层
                    - 是否允许service层访问业务规则【应该由应用层访问等等】
                    - 是否允许controller之间访问? service之间?
            类
                类定义了系统之间交互的细节 具体来说需要把类的粒度把控好 使得每个类可以把细节分解的恰到好处 同时 有能独立工作
                    - 类过于粗 controller 承担了太多功能  service太轻 承担了较少的功能
            子程序 一般由一些private方法构成 良好的描述了类的细节 同时可能会产生在一个类之间的层次结构 也可能反过来思考类的定义
                比较 f1();f2();f3() 并列调用 和  f1(f2(f3())) 层级调用
                    - 并列调用更强调顺序 层级封装更好
            子程序内部 完成功能 组织代码

    自上而下 自下而上
        自上而下
            - 延迟细节
            - 分解
        自下而上
            - 较早的明确系统的功能 从而带来更加准确的设计
            - 如果有相似的功能可以很好的决定重用的部分
            - 无法独立使用 大多数人擅长分解 不擅长组合
            -
    保留设计成果 UML、图片
        - processOn

target
    简单性 = 软件管理的关键 = 减少同一时间需要关注的 本质复杂度 + 避免生成不必要的 偶然复杂度
        1 最小复杂度 某一时刻开发需要关注的内容尽可能少
        2 高扇入  低扇出
            某一个类被其他类大量引用   某一个类引用了很少的其他类
        3 层次性
            在每一个层次应该可以独立观察而不用进入其他层次  或者说 每个层次都应该获得一致性的观察结果
    尝试的可能性越多 = 设计的结果越好
    信息隐藏的思考 = 解决复杂问题的概念