示例1 - 通过redis分担数据库压力 10w -> 2台redis -> mysql

缓存的适用场景
    1 多读少写
    2 性能要求高
    3 允许不一致性
    -- ? --
    4 存在热数据的应用
    5 需要实现分布式

不适用
    1 读少
    2 平凡更新
    3 对一致性要求高

CPU缓存行与伪共享
    缓存行 = 缓存操作最小的单元 一般为64k
    伪共享 = 缓存的数据在同一个缓存行中 导致存取数据的资源竞争 从而影响性能
    示例 JVM内存模型中 各个变量、对象的内存大小 --?--
    通过补齐64k对比效率 会有明显的不同

从CPU到互联网
    高可用
        通过 主从完成高可用
        通过 分片 分割大数据查询
        通过 集群 缓解查询压力

    高并发
        异步 并行

常用框架对比
分布式缓存     数据结构                          持久        复制模型    线程模型   存储结构                  高可用
redis           string、list、set、hash、zset    aof、rdb      主从       单线程    压缩串、字典、跳表[?]    cluster、sentinel
memcache
tair

redis vs memcache
    1 数据类型
        redis支持5种数据类型 而 memcache只支持key-value形式
            redis 底层使用跳表 保证高性能查询 log2(N) 并且在修改上成本低于 红黑树

    2 线程模型
        redis为单线程模型
        面对复杂的长逻辑 可能会产生阻塞的问题 可以启动多个redis实例提高CPU的利用率
        并且由于是单线程 提供了 批处理 和 管道的功能 简单易操作
            底层使用epoll 非阻塞网络I/O

        memcache 多线程非阻塞I/O

    3 持久化
        redis RDB 和 AOF 通过内存快照 和 日志保存数据
        memcache 需要依赖第三方

    4 客户端
        Jedis 阻塞I/O 需要配置连接池使用
        memcache...

    5 高可用
        redis RDB AOP sentinel cluster
        memcache 第三方

    6 队列
        redis list结构 lpush brpop
            brpop block right pop 也就是从list尾部移除元素  如果没有就会阻塞 等待有可用的元素为止
        发布订阅
            publish subscribe psubscribe
                psubscribe 根据pattern匹配channel
        memcache 不支持

    7 事务
        multi/exec  watch  inc 等等  单线程自动保证单个操作的事务  但是不保证复合操作的事务

    8 数据淘汰策略
        redis数据淘汰策略? lru ttl

    9 内存分配 略
 总体  redis更简单 功能更强大 应用更广泛

 ----------------------------------------
 Redis 使用相关
    使用场景
        1 直接使用json字符串保存  问题 修改某个信息困难 需要取出整个json修改
        2 使用hash  用  表名:id 作为hashset的key 保存k-v作为键值对 方便查询和修改
            例如  HSET good:1 price 100
                  HGET good:1 price

    高可用 - 哨兵 sentinel
        哨兵保证自动主从切换 实现了RAFT 保证选主的一致性
        概念
            哨兵至少要有3个 保证1个结点down掉之后 另外2个可以进行选举 选举出一个master并且切换  同步配置
        问题 在master down 到 完成主从切换的时间内的数据丢失 并且 master重启之后变为slave 此时配置也不会更新
             作为缓存是可以接受的 但是作为数据存储不能接受
        解决 通过配置 min-slave-write 可以保证 如果mater不能同步slave的情况 则拒绝访问

    redis集群
        自动分片

------------------------------------------
  访问模式
    1 双读双写  最为常见的模式  spring注解支持 @cacheable
        实现简单  对应用不透明  需要按顺序进行读写

    2 异步更新  所有操作在缓存中进行 通过异步任务同步缓存和数据库
        性能最好 但是设计维护复杂 需要有完善的监控和报警机制 否则会造成数据不一致

    3 串联  代理模式?

---------------------------------------------------
  分片模式
    1 应用层分片 实现简单 容错高
    2 代理层 通过协议路由分片 分离业务逻辑  增加成本
    3 缓存自带的分片 例如redis

---------------------------------------------------
    缓存常见问题
    1 缓存穿透  由恶意攻击 或者 无意的设计造成  大量的请求查询不存在的key导致流量下放到数据库
        解决方法 缓存空值的key  或者在业务层判断 拦截非法请求
    2 缓存并发  有设计不足造成  当 某一个 缓存失效时  有多个请求并发请求这个数据 就会造成并发访问数据库并回写缓存 导致瞬时的大流量
        解决 1 分布式锁  让单个线程执行这个操作
             2 软过期  由业务层控制缓存
                过期之后 首先延长时效
                然后由一个后台线程更新缓存 在这期间任然使用旧数据

    3 缓存雪崩  由缓存同时失效造成  在某一个时间点 大量的缓存同时失效 导致流量过大
        解决 设置不同的失效时间 = 基础时间 + 随机数